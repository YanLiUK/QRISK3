#Consider packages
#mfp
install.packages("mfp")
#Consider packages
#mfp
library(mfp)
#get data
data(GBSG)
View(GBSG)
data(iris)
iris
#get data
iris_fp <- iris
View(iris_fp)
unique(iris_fp$Species)
iris_fp[iris_fp$Species=="setosa" | iris_fp$Species=="versicolor"]$outcome <- 1
iris_fp$outcome[iris_fp$Species=="setosa" | iris_fp$Species=="versicolor"] <- 1
View(iris_fp)
iris_fp$outcome[iris_fp$Species=="virginica"] <- 0
View(iris_fp)
View(iris_fp)
str(iris)
#change one of predictor as the probability (mimic the real data)
iris_fp$"anti_prob" <- iris_fp$"Sepal.Length"
View(iris_fp)
f <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05)
+ Sepal.Width + Petal.Length + Petal.Width, family = binomial(), data = iris_fp)
warnings()
#Freash start
rm(list=ls())
#This program aims to consider FP and select the best FP
#using logistic regression with an outcome of 0/1 as binary
#and probability as the only continous variable
#also other confounders
#Consider 8 combinations of basic FP and more combinations if you consider more
# This defines 8 transformations, including inverse (x−1), log (x0), square root (x0.5), linear (x1),
# squared (x2) and cubic transformations (x3). In addition to these 8 “FP1” functions
# 28 “FP2” functions can be considered of the form xp1 + xp2;
# if p1 = p2 we define another 8 FP2 functions as xp + xp log(x),
# for a total of 36 FP2 functions
# For medical problems, two terms (FP2 transformations) have been suggested
# as sufficient to describe nonlinear relations
#Consider packages
#mfp
library(mfp)
# install.packages("mfp")
#get data
iris_fp <- iris
str(iris)
unique(iris_fp$Species)
iris_fp$outcome[iris_fp$Species=="setosa" | iris_fp$Species=="versicolor"] <- "1"
iris_fp$outcome[iris_fp$Species=="virginica"] <- "0"
iris_fp$"anti_prob" <- iris_fp$"Sepal.Length"
str(iris_fp)
iris_fp$outcome <- as.factor(iris_fp$outcome)
str(iris_fp)
f <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05)
+ Sepal.Width + Petal.Length + Petal.Width, family = binomial(), data = iris_fp)
warnings()
str(iris_fp)
f
f <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05)
+ Petal.Width, family = binomial(), data = iris_fp)
f
summary(f)
f <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05), family = binomial(), data = iris_fp)
f
iris_fp$"confound1" <- sample(100, size = nrow(data), replace = TRUE)
iris_fp$"confound1" <- sample(100, size = nrow(iris_fp), replace = TRUE)
View(iris_fp)
iris_fp$"confound1" <- sample(0.1, size = nrow(iris_fp), replace = TRUE)
View(iris_fp)
iris_fp$"confound1" <- sample(100, size = nrow(iris_fp), replace = TRUE) / 100
View(iris_fp)
View(iris_fp)
set.seed(1)
iris_fp$"confound1" <- sample(100, size = nrow(iris_fp), replace = TRUE) / 100
set.seed(2)
iris_fp$"confound2" <- sample(100, size = nrow(iris_fp), replace = TRUE) / 100
View(iris_fp)
f <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05) + confound1 + confound2, family = binomial(), data = iris_fp)
f
summary(f)
f.object
f_valid <- glm(formula = outcome ~ I((anti_prob/10)^1) + confound2 + confound1,
family = binomial(), data = iris_fp)
f_valid
summary(f)
f_valid1 <- glm(formula = outcome ~ anti_prob + (anti_prob/10)^1 + confound2 + confound1,
family = binomial(), data = iris_fp)
f_valid1 <- glm(formula = outcome ~ anti_prob + ((anti_prob/10)^1) + confound2 + confound1,
family = binomial(), data = iris_fp)
iris_fp$fp_comp <- (iris_fp$anti_prob/10)^1
f_valid1 <- glm(formula = outcome ~ fp_comp + confound2 + confound1,
family = binomial(), data = iris_fp)
summary(f_valid1)
summary(f)
summary(f_valid)
summary(f_valid1)
f_no_fp <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05)
+ Sepal.Width + Petal.Length + Petal.Width, family = binomial(), data = iris_fp)
warnings()
summary(f_no_fp)
f_low_fp <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05)
+ Petal.Width, family = binomial(), data = iris_fp)
summary(f_low_fp)
f_low_fp <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05), family = binomial(), data = iris_fp)
summary(f_low_fp)
f_low_fp <- mfp(outcome ~ fp(anti_prob, df = 5, select = 0.05), family = binomial(), data = iris_fp)
summary(f_low_fp)
f_low_fp <- mfp(outcome ~ fp(anti_prob, df = 100, select = 0.05), family = binomial(), data = iris_fp)
summary(f_low_fp)
str(iris_fp)
str(iris_fp)
glm(formula = outcome ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width,
family = binomial(), data = iris_fp)
glm(formula = outcome ~ Sepal.Length + Sepal.Width + Petal.Width,
family = binomial(), data = iris_fp)
View(iris_fp)
glm(formula = outcome ~ Sepal.Width + Petal.Width,
family = binomial(), data = iris_fp)
#Freash start
rm(list=ls())
#This program aims to consider FP and select the best FP
#using logistic regression with an outcome of 0/1 as binary
#and probability as the only continous variable
#also other confounders
#Consider 8 combinations of basic FP and more combinations if you consider more
# This defines 8 transformations, including inverse (x−1), log (x0), square root (x0.5), linear (x1),
# squared (x2) and cubic transformations (x3). In addition to these 8 “FP1” functions
# 28 “FP2” functions can be considered of the form xp1 + xp2;
# if p1 = p2 we define another 8 FP2 functions as xp + xp log(x),
# for a total of 36 FP2 functions
# For medical problems, two terms (FP2 transformations) have been suggested
# as sufficient to describe nonlinear relations
#Consider packages
#mfp
library(mfp)
# install.packages("mfp")
#get data
iris_fp <- iris
str(iris)
unique(iris_fp$Species)
iris_fp$outcome[iris_fp$Species=="setosa" | iris_fp$Species=="versicolor"] <- "1"
iris_fp$outcome[iris_fp$Species=="virginica"] <- "0"
iris_fp$outcome <- as.factor(iris_fp$outcome)
#change one of predictor as the probability (mimic the real data)
#the other variables were not suitable for confounders as they are explainotory in this case
#add random variable as confounders
iris_fp$"anti_prob" <- iris_fp$"Sepal.Width"
set.seed(1)
iris_fp$"confound1" <- sample(100, size = nrow(iris_fp), replace = TRUE) / 100
set.seed(2)
iris_fp$"confound2" <- sample(100, size = nrow(iris_fp), replace = TRUE) / 100
str(iris_fp)
#all model
glm(formula = outcome ~ Sepal.Width + Petal.Width,
family = binomial(), data = iris_fp)
f <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05) + Petal.Width + confound1 + confound2, family = binomial(), data = iris_fp)
# f
summary(f)
f <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05) + Petal.Width + confound1 + confound2, family = binomial(), data = iris_fp)
# f
summary(f)
f <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05) + Petal.Width + confound1 + confound2, family = binomial(), data = iris_fp)
# f
warnings()
glm(formula = outcome ~ Sepal.Width + Petal.Width,
family = binomial(), data = iris_fp)
View(iris_fp)
f <- mfp(outcome ~ fp(anti_prob, df = 4, select = 0.05) + confound1 + confound2, family = binomial(), data = iris_fp)
# f
summary(f)
f_valid <- glm(formula = outcome ~ I(anti_prob^-1) + I(anti_prob^-1 * log(anti_prob)) + confound2 + confound1,
family = binomial(), data = iris_fp)
summary(f_valid)
iris_fp$fp_comp1 <- anti_prob^-1
iris_fp$fp_comp2 <- anti_prob^-1 * log(anti_prob)
f_valid1 <- glm(formula = outcome ~ fp_comp1 + fp_comp2 + confound2 + confound1,
family = binomial(), data = iris_fp)
summary(f_valid1)
iris_fp$fp_comp1 <- iris_fp$anti_prob^-1
iris_fp$fp_comp2 <- iris_fp$anti_prob^-1 * log(iris_fp$anti_prob)
f_valid1 <- glm(formula = outcome ~ fp_comp1 + fp_comp2 + confound2 + confound1,
family = binomial(), data = iris_fp)
summary(f_valid1)
summary(f)
f <- mfp(outcome ~ fp(anti_prob, df = 5, select = 0.05) + confound1 + confound2, family = binomial(), data = iris_fp)
# f
summary(f)
summary(f)
dt_ant1 <- read.csv(pasteo(rootpath, "abindic2.csv"))
rootpath <- "/Volumes/U_DISK/Co_author_anti"
#get sample data ready----------------------------------------------------------------
dt_ant1 <- read.csv(pasteo(rootpath, "abindic2.csv"))
rootpath <- "/Volumes/U_DISK/Co_author_anti"
#get sample data ready----------------------------------------------------------------
dt_ant1 <- read.csv(paste0(rootpath, "abindic2.csv"))
print(wd)
rootpath <- "/Users/tomgauss/Volumes/U_DISK/Co_author_anti"
#get sample data ready----------------------------------------------------------------
dt_ant1 <- read.csv(paste0(rootpath, "abindic2.csv"))
rootpath <- "/Users/tomgauss/Volumes/U_DISK/Co_author_anti/"
#get sample data ready----------------------------------------------------------------
dt_ant1 <- read.csv(paste0(rootpath, "abindic2.csv"))
getwd()
rootpath <- "Volumes/U_DISK/Co_author_anti/"
#get sample data ready----------------------------------------------------------------
dt_ant1 <- read.csv(paste0(rootpath, "abindic2.csv"))
rootpath <- "Volumes/U_DISK/Co_author_anti/"
#get sample data ready----------------------------------------------------------------
dt_ant1 <- read.csv(paste0(getwd(),rootpath, "abindic2.csv"))
rootpath <- "Volumes/U_DISK/Co_author_anti/"
#get sample data ready----------------------------------------------------------------
dt_ant1 <- read.csv(paste0(getwd(),"/",rootpath, "abindic2.csv"))
rootpath <- "Volumes/U_DISK/Co_author_anti/"
setwd(rootpath)
#get sample data ready----------------------------------------------------------------
dt_ant1 <- read.csv(file=paste0(getwd(),"/",rootpath, "abindic2.csv"), header=TRUE, sep=",")
rootpath <- "Volumes/U_DISK/Co_author_anti/"
#get sample data ready----------------------------------------------------------------
dt_ant1 <- read.csv(file=paste0(rootpath, "abindic2.csv"), header=TRUE, sep=",")
rootpath <- "/Volumes/U_DISK/Co_author_anti/"
#get sample data ready----------------------------------------------------------------
dt_ant1 <- read.csv(file=paste0(rootpath, "abindic2.csv"), header=TRUE, sep=",")
View(dt_ant1)
dt_ant2 <- read.csv(file=paste0(rootpath, "abindic8.csv"), header=TRUE, sep=",")
dt_ant3 <- read.csv(file=paste0(rootpath, "abindic167.csv"), header=TRUE, sep=",")
View(dt_ant2)
View(dt_ant3)
View(dt_ant1)
str(dt_ant1)
str(dt_ant2)
str(dt_ant3)
#Freash start
rm(list=ls())
#This program aims to consider FP and select the best FP
#using logistic regression with an outcome of 0/1 as binary
#and probability as the only continous variable
#also other confounders
#Consider 8 combinations of basic FP and more combinations if you consider more
# This defines 8 transformations, including inverse (x−1), log (x0), square root (x0.5), linear (x1),
# squared (x2) and cubic transformations (x3). In addition to these 8 “FP1” functions
# 28 “FP2” functions can be considered of the form xp1 + xp2;
# if p1 = p2 we define another 8 FP2 functions as xp + xp log(x),
# for a total of 36 FP2 functions
# For medical problems, two terms (FP2 transformations) have been suggested
# as sufficient to describe nonlinear relations
#Consider packages
#mfp
library(mfp)
# install.packages("mfp")
rootpath <- "/Volumes/U_DISK/Co_author_anti/"
#get sample data ready----------------------------------------------------------------
tom_mfp <- (dt) {
dt_ant1 <- read.csv(file=paste0(rootpath, dt), header=TRUE, sep=",")
dt_ant1$abrx_sd <- as.factor(dt_ant1$abrx_sd)
f <- mfp(abrx_sd ~ fp(prob_case119, df = 4, select = 0.05) + year_dtindex,
family = binomial(), data = dt_ant1)
summary(f)
}
#################################################################################
#   This progam aims to write a fractional polynoimal program for logistic model
#    in order to support Tjeerd's antibiotic paper
#
#  Author: Yan Li
#  Contact: yan.li-16@postgrad.manchester.ac.uk
################################################################################
#Freash start
rm(list=ls())
#This program aims to consider FP and select the best FP
#using logistic regression with an outcome of 0/1 as binary
#and probability as the only continous variable
#also other confounders
#Consider 8 combinations of basic FP and more combinations if you consider more
# This defines 8 transformations, including inverse (x−1), log (x0), square root (x0.5), linear (x1),
# squared (x2) and cubic transformations (x3). In addition to these 8 “FP1” functions
# 28 “FP2” functions can be considered of the form xp1 + xp2;
# if p1 = p2 we define another 8 FP2 functions as xp + xp log(x),
# for a total of 36 FP2 functions
# For medical problems, two terms (FP2 transformations) have been suggested
# as sufficient to describe nonlinear relations
#Consider packages
#mfp
library(mfp)
# install.packages("mfp")
rootpath <- "/Volumes/U_DISK/Co_author_anti/"
#get sample data ready----------------------------------------------------------------
tom_mfp <- function(dt) {
dt_ant1 <- read.csv(file=paste0(rootpath, dt), header=TRUE, sep=",")
dt_ant1$abrx_sd <- as.factor(dt_ant1$abrx_sd)
f <- mfp(abrx_sd ~ fp(prob_case119, df = 4, select = 0.05) + year_dtindex,
family = binomial(), data = dt_ant1)
summary(f)
}
tom_mfp("abindic2.csv")
tom_mfp("abindic2.csv")
abdc2 <- load(paste0(rootpath, "abindic2.csv","_rst.Rdata"))
f
abdc2 <- load(file=paste0(rootpath, "abindic2.csv","_rst.Rdata"))
x<-1
save(x, file = paste0(rootpath,"x_rst.Rdata"))
paste0(rootpath,"x_rst.Rdata")
x<-1
save(x, file = paste0(getwd(), rootpath,"x_rst.Rdata"))
x<-1
save(x, file = paste0(rootpath,"x_rst.Rdata"))
load(file=paste0(rootpath, "x","_rst.Rdata"))
tom_mfp("abindic2.csv")
#load the saved model
abdc2 <- load(file=paste0(rootpath, "abindic2.csv","_rst.Rdata"))
tom_mfp <- function(dt) {
dt_ant1 <- read.csv(file=paste0(rootpath, dt), header=TRUE, sep=",")
dt_ant1$abrx_sd <- as.factor(dt_ant1$abrx_sd)
f <- mfp(abrx_sd ~ fp(prob_case119, df = 4, select = 0.05) + year_dtindex,
family = binomial(), data = dt_ant1)
summary(f)
save(f, file = paste0(rootpath, dt,"_rst.Rdata"))
}
tom_mfp("abindic2.csv")
fp_rst1 <- load(file=paste0(rootpath, "abindic2.csv","_rst.Rdata"))
str(fp_rst1)
fp_rst1
fp_rst1
summary(fp_rst1)
summary(fp_rst1$f)
fp_rst1$coefficients
fp_rst1[coefficients]
f
f$formula
f$formula
f
fp_rst1
summary(f)
tom_mfp <- function(dt) {
dt_ant1 <- read.csv(file=paste0(rootpath, dt), header=TRUE, sep=",")
dt_ant1$abrx_sd <- as.factor(dt_ant1$abrx_sd)
f <- mfp(abrx_sd ~ fp(prob_case119, df = 4, select = 0.05) + year_dtindex,
family = binomial(), data = dt_ant1)
summary(f)
save(summary(f), file = paste0(rootpath, dt,"_rst.Rdata"))
}
tom_mfp("abindic2.csv")
#################################################################################
#   This progam aims to write a fractional polynoimal program for logistic model
#    in order to support Tjeerd's antibiotic paper
#
#  Author: Yan Li
#  Contact: yan.li-16@postgrad.manchester.ac.uk
################################################################################
#Freash start
rm(list=ls())
#This program aims to consider FP and select the best FP
#using logistic regression with an outcome of 0/1 as binary
#and probability as the only continous variable
#also other confounders
#Consider 8 combinations of basic FP and more combinations if you consider more
# This defines 8 transformations, including inverse (x−1), log (x0), square root (x0.5), linear (x1),
# squared (x2) and cubic transformations (x3). In addition to these 8 “FP1” functions
# 28 “FP2” functions can be considered of the form xp1 + xp2;
# if p1 = p2 we define another 8 FP2 functions as xp + xp log(x),
# for a total of 36 FP2 functions
# For medical problems, two terms (FP2 transformations) have been suggested
# as sufficient to describe nonlinear relations
#Consider packages
#mfp
library(mfp)
# install.packages("mfp")
rootpath <- "/Volumes/U_DISK/Co_author_anti/"
#get sample data ready----------------------------------------------------------------
tom_mfp <- function(dt) {
dt_ant1 <- read.csv(file=paste0(rootpath, dt), header=TRUE, sep=",")
dt_ant1$abrx_sd <- as.factor(dt_ant1$abrx_sd)
f <- mfp(abrx_sd ~ fp(prob_case119, df = 4, select = 0.05) + year_dtindex,
family = binomial(), data = dt_ant1)
summary(f)
f_sum <- summary(f)
save(f_sum, file = paste0(rootpath, dt,"_rst.Rdata"))
}
tom_mfp("abindic2.csv")
file1<-"abindic2.csv"
#load the saved model
fp_rst1 <- load(file=paste0(rootpath, file1,"_rst.Rdata"))
fp_rst1
f_sum
library(devtools)
install.packages("devtools")
library(devtools)
install_github("YanliUK/QRISK3", auth_token="tomgaussQRISK")
install_github("DylanRJCollins/whoishRisk")
install_github("YanliUK/QRISK3", auth_token="tomgaussQRISK")
install_github("YanliUK/QRISK3", auth_token="tomgaussQRISK")
res <- httr::GET("https://github.com/YanLiUK/QRISK3")
httr::status_code(res)
res <- httr::GET("https://github.com")
httr::status_code(res)
res <- httr::GET("https://github.com/YanLiUK")
httr::status_code(res)
res <- httr::GET("https://github.com/YanLiUK/QRISK3_2017")
httr::status_code(res)
?install_github
GITHUB_PAT <- "git: https://github.com/ on DESKTOP-BF3NCMR at 20-Nov-2019 09:23"
install_github("YanliUK/QRISK3", auth_token=GITHUB_PAT )
GITHUB_PAT <- "6cf69b9bb04820178a467938cc0412aa3be95b22"
install_github("YanliUK/QRISK3", auth_token=GITHUB_PAT )
library(QRISK3)
?QRISK3_2017
data(QRISK3_2019_test)
test_all <- QRISK3_2019_test
test_all_rst <- QRISK3_2017(data=test_all, patid="ID", gender="gender", age="age",
atrial_fibrillation="b_AF", atypical_antipsy="b_atypicalantipsy",
regular_steroid_tablets="b_corticosteroids", erectile_disfunction="b_impotence2",
migraine="b_migraine", rheumatoid_arthritis="b_ra",
chronic_kidney_disease="b_renal", severe_mental_illness="b_semi",
systemic_lupus_erythematosis="b_sle",
blood_pressure_treatment="b_treatedhyp", diabetes1="b_type1",
diabetes2="b_type2", weight="weight", height="height",
ethiniciy="ethrisk", heart_attack_relative="fh_cvd",
cholesterol_HDL_ratio="rati", systolic_blood_pressure="sbp",
std_systolic_blood_pressure="sbps5", smoke="smoke_cat", townsend="town")
test_all_rst$"QRISK_web_score" <- test_all$"QRISK_web_score"
test_all_rst$"diff" <- test_all_rst$"QRISK3_2017_1digit" - test_all_rst$"QRISK_web_score"
print(test_all_rst$"diff")
print(identical(test_all_rst$"QRISK3_2017_1digit", test_all_rst$"QRISK_web_score"))
View(QRISK3_2019_test)
source('/Volumes/KINGSTON/QRISK3 package paper/Publish QRISK3/Pacakge build.R', echo=TRUE)
